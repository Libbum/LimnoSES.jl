var documenterSearchIndex = {"docs":
[{"location":"api/","page":"Public API","title":"Public API","text":"None of this is final, but some current public facing functions:","category":"page"},{"location":"api/","page":"Public API","title":"Public API","text":"initialise\nlake_initial_state\nplanner\nplan\npolicy\nscan\nobjectives\nobjective","category":"page"},{"location":"api/#LimnoSES.initialise","page":"Public API","title":"LimnoSES.initialise","text":"initialise()\n\nReturns a populated model initialised and ready to run.\n\n\n\n\n\n","category":"function"},{"location":"api/#LimnoSES.lake_initial_state","page":"Public API","title":"LimnoSES.lake_initial_state","text":"lake_initial_state(<:LakeDefinition, <:LakeModel)\n\nProvides initial conditions of the lake. Parameters are model dependent. For example: lake_initial_state(Clear, Martin).\n\n\n\n\n\nlake_initial_state(nutrients, bream, pike, vegetation, Martin)\n\nProvides initial conditions of the lake with specified values.\n\n\n\n\n\nlake_initial_state(nutrients, <:LakeDefinition, Martin)\n\nA special override that returns interpolated results from precaclulated Clear and Turbid bifurcation results. Not as precise as the preset conditions, since the numbers do not come directly from the analytical solution, but close.\n\n\n\n\n\n","category":"function"},{"location":"api/#LimnoSES.planner","page":"Public API","title":"LimnoSES.planner","text":"planner(plan(Angling))\nplanner(plan(Planting; rate=5e-3),\n        plan(Trawling, 1:3))\n\nProvides a complete schedule of interventions for a Municipality. Must be used in conjunction with plan.\n\n\n\n\n\n","category":"function"},{"location":"api/#LimnoSES.plan","page":"Public API","title":"LimnoSES.plan","text":"plan(Angling) # Assume always on\nplan(Angling; rate = 2.5e-3) # Always on with custom rate\nplan(Angling, 7; rate = 3.2e-3) # Only one year (custom rate)\nplan(Angling, 3:5) # Only years 3 to 5\nplan(Angling, [(period = 1:4, ),\n               (year = 5, rate = 7.2e-3),\n               (period = 7:9, )]) # Active in years 1-5, 7-9 with a custom rate\n                                  # in year 5\n\nHelper that provides complex scheduling for interventions with a simple interface.\n\nThe return type is Dict{Int, Vector{Intervention}}, were the key is each year the collection of interventions will be active. As a convention, year -1 denotes an 'always active' intervention.\n\nThe result can be provided to municipality.interventions, although this function should almost always used in conjunction with planner.\n\n\n\n\n\n","category":"function"},{"location":"api/#LimnoSES.policy","page":"Public API","title":"LimnoSES.policy","text":"policy(scan(Trawling), scan(Planting; rate = (1e-5, 2.6e-3)))\n\nEnables the decision module to alter suggested planner values, optimising the system state when possible. Used to set the policies of each Municipality.\n\n\n\n\n\n","category":"function"},{"location":"api/#LimnoSES.scan","page":"Public API","title":"LimnoSES.scan","text":"scan(Trawling) # Activate decisions on trawling using default ranges.\nscan(Trawling; rate = (5e-3, 2e-2)) # Activate trawling decisions with custom\n                                    # search range for `rate`.\n\nUse the decision making optimiser to fine tune values in the planner. scan expects a lower and upper bound of a range to scan for each intervention property. For the moment, this strategy excludes WastewaterTreatment, and does not adjust active years. These must still be set in the planner.\n\nShould be used in conjunction with policy.\n\n\n\n\n\n","category":"function"},{"location":"api/#LimnoSES.objectives","page":"Public API","title":"LimnoSES.objectives","text":"objectives(objective(min_time), objective(min_cost, 0.5))\n\nConstructs a set of objectives which will be used to optimise policy towards the chosen target.\n\n\n\n\n\n","category":"function"},{"location":"api/#LimnoSES.objective","page":"Public API","title":"LimnoSES.objective","text":"objective(min_time)\nobjective(min_acceleration, 2)\n\nProvides a weighted objective to be used when optimising policy. Should be used in conjunction with objectives.\n\nWhen providing a weight, this value can be any positive Real number which will rank this objective higher or lower than other objectives. It is not imperative to make sure all numbers entered in the policy to add up to 100%, but bear in mind that the values will be normalised for the optimisation.\n\n\n\n\n\n","category":"function"},{"location":"api/#NutrientSeries","page":"Public API","title":"NutrientSeries","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"NutrientSeries is an abstract type from which concrete types can be implemented to describe the dynamics of nutrient introduction to the lake.","category":"page"},{"location":"api/","page":"Public API","title":"Public API","text":"Constant\nDynamic\nTransientUp\nTransientDown\nNoise","category":"page"},{"location":"api/#LimnoSES.Constant","page":"Public API","title":"LimnoSES.Constant","text":"Constant()\n\nNutrient level remains constant at the level of init_nutrients.\n\n\n\n\n\n","category":"type"},{"location":"api/#LimnoSES.Dynamic","page":"Public API","title":"LimnoSES.Dynamic","text":"Dynamic()\n\nNutrient runoff is managed by the municipality by incentivising households to upgrade sewage systems that seep P into the lake.\n\n\n\n\n\n","category":"type"},{"location":"api/#LimnoSES.TransientUp","page":"Public API","title":"LimnoSES.TransientUp","text":"TransientUp(;start_year = 11, post_target_series = Constant())\n\nSynthetic nutrient profile that alters lake dynamics regardless of municipal management.\n\nstart_year: year when nutrients begin to increase with a rate of nutrient_change.\npost_target_series: behaviour after target_nutrients value is reached.   Default is TransientDown(start_year = 0, post_target_series = Constant())\n\nwarning: Warning\nPost target series selection must include a final Constant phase, otherwise an infinite recursion cascade will occur.\n\n\n\n\n\n","category":"type"},{"location":"api/#LimnoSES.TransientDown","page":"Public API","title":"LimnoSES.TransientDown","text":"TransientDown(;start_year = 11, post_target_series = Constant())\n\nSynthetic nutrient profile that alters lake dynamics regardless of municipal management.\n\nstart_year: year when nutrients begin to decrease with a rate of nutrient_change.\npost_target_series: behaviour after target_nutrients value is reached.   Default is TransientUp(start_year = 0, post_target_series = Constant())\n\nwarning: Warning\nPost target series selection must include a final Constant phase, otherwise an infinite recursion cascade will occur.\n\n\n\n\n\n","category":"type"},{"location":"api/#LimnoSES.Noise","page":"Public API","title":"LimnoSES.Noise","text":"Noise(process, min, max)\n\nNoise process given by DiffEqNoiseProcess.jl. For the moment this does not connect to the actual start time or init_nutrients value, so these must be manually duplicated here. Will be fixed in the future. min and max nutrient values can also be applied.\n\nwarning: Warning\nCare must be taken to verify that bounded processes are possible over certain time horizons. This is noticably the case with brownian bridges. If your σ is small such that the gap between your current position and the end position cannot be met within the timeframe specified, the solver will error. Unfortunately this cannot be handled in a softer manner.\n\n\n\n\n\n","category":"type"},{"location":"api/#Decisions","page":"Public API","title":"Decisions","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"This system uses BlackBoxOptim.jl to set intervention policies that satisfy a number of objectives whilst attempting to reach a given target.","category":"page"},{"location":"api/","page":"Public API","title":"Public API","text":"LimnoSES.make_decision!","category":"page"},{"location":"api/#LimnoSES.make_decision!","page":"Public API","title":"LimnoSES.make_decision!","text":"make_decision!(model)\n\nRuns the optimisation routine, calling on policy ranges set via policy. Decisions are made only from the year of the call onwards.\n\n\n\n\n\n","category":"function"},{"location":"api/#Targets","page":"Public API","title":"Targets","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"Targets are written in the form of an Agents.jl until function. Any stopping condition is possible and can be user generated, although there must be a hard stop at some point in the future. s == 100 && return true is the default. The following examples are pre-defined:","category":"page"},{"location":"api/","page":"Public API","title":"Public API","text":"LimnoSES.clear_state\nLimnoSES.managed_clear_eutrophic","category":"page"},{"location":"api/#LimnoSES.clear_state","page":"Public API","title":"LimnoSES.clear_state","text":"clear_state(model, s)\n\nTargets the clear lake steady state, with an extra stopping condition if that state was not reached within 100 years.\n\nCalculated via instantaneous comparisons at latest model time of all lake variables, with an additional check to verify a near-zero first derivative.\n\nNOTE: This target is hard coded to the default Martin parameters.\n\n\n\n\n\n","category":"function"},{"location":"api/#LimnoSES.managed_clear_eutrophic","page":"Public API","title":"LimnoSES.managed_clear_eutrophic","text":"managed_clear_eutrophic(model, s)\n\nTargets the T3 state, which is a high nutrient (N>=3), unstable state with a high pike population. Will stop at 100 years if not successful.\n\nNote: For the moment this targets the region of T3, not the explicit starting point.\n\n\n\n\n\n","category":"function"},{"location":"api/#Objectives","page":"Public API","title":"Objectives","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"There is no 'right' way of meeting a target, since we may have multiple objectives to contend with. Objectives are a function that take model as an argument and return a Float64.","category":"page"},{"location":"api/","page":"Public API","title":"Public API","text":"Once created, these should be initialised using objective, since the model also expects an associated weight.","category":"page"},{"location":"api/","page":"Public API","title":"Public API","text":"Pre-defined values:","category":"page"},{"location":"api/","page":"Public API","title":"Public API","text":"LimnoSES.min_time\nLimnoSES.min_acceleration\nLimnoSES.min_cost\nLimnoSES.appropreate_vegetation","category":"page"},{"location":"api/#LimnoSES.min_time","page":"Public API","title":"LimnoSES.min_time","text":"min_time(model)\n\nObjective function that returns the time of the model at the end of a run. If a target function is interested in moving from one state to the next in the quickest amount of time, this is a useful objective.\n\n\n\n\n\n","category":"function"},{"location":"api/#LimnoSES.min_acceleration","page":"Public API","title":"LimnoSES.min_acceleration","text":"min_acceleration(model)\n\nObjective function that returns the sum of the absolute value of the second derivative of all lake variables. Span is from start of the optimisation to the final model.year with monthly increments.\n\nHelps to mitigate large spikes in transitions.\n\n\n\n\n\n","category":"function"},{"location":"api/#LimnoSES.min_cost","page":"Public API","title":"LimnoSES.min_cost","text":"min_cost(model)\n\nObjective function that returns a \"cost\" of future Planting and Trawling interventions, which ultimately is just a sum of all proposed rates.\n\nnote: Note\nWhen using nutrient_series = Noise(...) and only the min_cost objective, opt_replicates must be large (≳ 10), since the noise process may cause the optimiser to identify a solution in theory but fail in practice. The solution to failing meet the target scenario in this case is increase opt_replicates and retry.\n\n\n\n\n\n","category":"function"},{"location":"dev/","page":"Developer Docs","title":"Developer Docs","text":"Non exported functions can be found here.","category":"page"},{"location":"dev/","page":"Developer Docs","title":"Developer Docs","text":"LimnoSES.type2dict\nLimnoSES.nutrient_load!\nLimnoSES.active_interventions","category":"page"},{"location":"dev/#LimnoSES.type2dict","page":"Developer Docs","title":"LimnoSES.type2dict","text":"type2dict(struct; prefix = \"\")\n\nConverts a struct into a Dict. Borrowed from DrWatson, but extended to allow some prefix to be attached. This is helpful when merging multiple structs into one Dict.\n\n\n\n\n\n","category":"function"},{"location":"dev/#LimnoSES.nutrient_load!","page":"Developer Docs","title":"LimnoSES.nutrient_load!","text":"nutrient_load(model::ABM, series<:NutrientSeries)\n\nUpdates lake nutrient concentration accorting to series type.\n\nSee NutrientSeries for more details.\n\n\n\n\n\n","category":"function"},{"location":"dev/#LimnoSES.active_interventions","page":"Developer Docs","title":"LimnoSES.active_interventions","text":"active_interventions(municipality, year)\n\nReturns all active interventions in the planner. Due to the year = -1 -> always active convention we must merge the current year's plan with the -1 key (if extant).\n\n\n\n\n\n","category":"function"},{"location":"dev/#Decisions-Private-Functions","page":"Developer Docs","title":"Decisions Private Functions","text":"","category":"section"},{"location":"dev/","page":"Developer Docs","title":"Developer Docs","text":"LimnoSES.create_test_model\nLimnoSES.apply_policies!\nLimnoSES.update_true_model!\nLimnoSES.cost\nLimnoSES.weightedfitness","category":"page"},{"location":"dev/#LimnoSES.create_test_model","page":"Developer Docs","title":"LimnoSES.create_test_model","text":"create_test_model(model)\n\nCreates a complete copy of the current model, with a modified set of interventions. All \"completed\" interventions (i.e. ones that have happened in the models' past) are ignored. This test model is then used in the optimisation procedure.\n\n\n\n\n\n","category":"function"},{"location":"dev/#LimnoSES.apply_policies!","page":"Developer Docs","title":"LimnoSES.apply_policies!","text":"apply_policies!(x, test::ABM)\n\nApplies new test values to all active intervention properties. Is used before each optimisation call, but also to finalise the decision process via a best_candidate call.\n\n\n\n\n\n","category":"function"},{"location":"dev/#LimnoSES.update_true_model!","page":"Developer Docs","title":"LimnoSES.update_true_model!","text":"update_true_model!(test, model)\n\nReconstructs each municipalities interventions property in the model after a successful optimisation run. Be careful with the model order here, as there's no simple way to differentiate the two of them via types.\n\n\n\n\n\n","category":"function"},{"location":"dev/#LimnoSES.cost","page":"Developer Docs","title":"LimnoSES.cost","text":"cost(x, u0, p, test::ABM)\n\nOptimization function. To be used in in conjunction with the bboptimize call only. Needs to be overloaded slightly, since we want to reset the lake dynamics at each call, so model.lake.u and model.lake.p are expected to be passed into the second and third variables respectively, with the cut down \"test\" version of the model being the last value.\n\n\n\n\n\n","category":"function"},{"location":"dev/#LimnoSES.weightedfitness","page":"Developer Docs","title":"LimnoSES.weightedfitness","text":"weightedfitness(f, weights)\n\nHandle objective weights. Should be used as an aggregator in bboptimize.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Introduction","title":"Introduction","text":"LimnoSES.jl is a dynamical system, agent based model hybrid, focusing on socio-ecological interactions in lake systems.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Powered by the Agents.jl ABM framework and the DifferentialEquations.jl ecosystem.","category":"page"},{"location":"#Quickstart","page":"Introduction","title":"Quickstart","text":"","category":"section"},{"location":"#Simple-Optimisation-Campaign","page":"Introduction","title":"Simple Optimisation Campaign","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"An example run looking at a planting & trawling campaign over 20 years, attempting to flip the lake state from Turbid to Clear with a 100 year time horizon","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using LimnoSES\n\nmodel = initialise(;\n    experiment = Experiment(\n        policy = Decision(\n            target = clear_state,\n            objectives = objectives(objective(min_time), objective(min_cost)),\n        ),\n        identifier = \"Turbid->Clear, constant Nutrients\",\n        nutrient_series = Constant(),\n    ),\n    lake_setup = lake_initial_state(S1, Martin),\n    municipalities = Dict(\n        \"main\" => (\n            Governance(\n                interventions = planner(plan(Planting, 1:20), plan(Trawling, 1:20)),\n                policies = policy(scan(Planting), scan(Trawling)),\n            ),\n            100,\n        ),\n    ),\n)\n\nfunction assets(model)\n    nutrients(model) = model.lake.p.nutrients\n    plant_rate(model) = model.lake.p.pv\n    trawl_rate(model) = model.lake.p.tb\n    return [nutrients, plant_rate, trawl_rate]\nend\n\n_, data = run!(model, agent_step!, model_step!, 100; mdata = assets(model))\n\nusing Plots\n\ndiscrete = model.lake.sol(0:12:365*100)\n\nhl = plot(\n    discrete;\n    labels = [\"Bream\" \"Pike\" \"Vegetation\"],\n    xticks = (0:365*5:365*100, 0:5:100),\n)\nhr = plot([data.plant_rate data.trawl_rate], labels = [\"Plant Rate\" \"Trawl Rate\"])\nhn = plot(data.nutrients, label = \"Nutrients\")\nl = @layout [a; b c]\nplot(hl, hr, hn, layout = l, size = (1000, 700))","category":"page"},{"location":"#Stochastic-Distributed-Campaign","page":"Introduction","title":"Stochastic Distributed Campaign","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A 20 year planting campaign, 100 year time horizon and Turbid to Clear target. This time using geometric Brownian motion within the bistable corridor to simulate wending nutrient levels. 10 complete runs, each with 10 projected optimiser calls with new random seeds on the nutrient noise process. Distributed over as many process as you wish, this example uses one control and 13 workers.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Distributed\naddprocs(13)\n@everywhere begin\n    import Pkg\n    Pkg.activate(@__DIR__)\nend\n\n@everywhere using LimnoSES\n@everywhere model = initialise(;\n    experiment = Experiment(\n        policy = Decision(\n            target = clear_state,\n            objectives = objectives(objective(min_time), objective(min_cost)),\n            opt_replicates = 10,\n        ),\n        identifier = \"noisy_N, Turbid->Clear\",\n        nutrient_series = Noise(\n            GeometricBrownianMotionProcess(0.0, 0.05, 0.0, 2.0),\n            1.0,\n            2.5,\n        ),\n    ),\n    lake_setup = lake_initial_state(S1, Martin),\n    municipalities = Dict(\n        \"main\" => (\n            Governance(\n                interventions = planner(plan(Planting, 1:20)),\n                policies = policy(scan(Planting)),\n            ),\n            100,\n        ),\n    ),\n)\n\n@everywhere function assets(model)\n    nutrients(model) = model.lake.p.nutrients\n    plant_rate(model) = model.lake.p.pv\n    trawl_rate(model) = model.lake.p.tb\n    discrete(model) = model.lake.sol(\n        (model.year > 1 ? 365 * (model.year - 1) + 36.5 : 0):36.5:365*model.year,\n    )\n    return [nutrients, plant_rate, trawl_rate, discrete]\nend\n\nreps = 10\nyears = 100\n_, data = replicates(model, agent_step!, model_step!, years, reps; mdata = assets(model))\n\nusing Plots, Statistics, DataFrames\n\ndiscrete = LimnoSES.OrdinaryDiffEq.VectorOfArray([\n    cat(\n        collect(Iterators.flatten(\n            d.u\n            for\n            d in\n            DataFrames.filter(\n                [:replicate, :step] => (r, s) -> r == i && s != 0,\n                data,\n            ).discrete\n        ))...,\n        dims = 2,\n    ) for i in 1:reps\n])\nt = 0:36.5:365*years\n\nhl = plot(\n    t,\n    mean(discrete[1, :, :], dims = 2),\n    ribbon = std(discrete[1, :, :], dims = 2),\n    label = \"Bream\",\n    linewidth = 2,\n    xticks = (0:365*5:365*years, 0:5:years),\n)\nplot!(\n    hl,\n    t,\n    mean(discrete[2, :, :], dims = 2),\n    ribbon = std(discrete[2, :, :], dims = 2),\n    label = \"Pike\",\n    linewidth = 2,\n)\nplot!(\n    hl,\n    t,\n    mean(discrete[3, :, :], dims = 2),\n    ribbon = std(discrete[3, :, :], dims = 2),\n    label = \"Vegetation\",\n    linewidth = 2,\n)\n\nplant_rate = reshape(data.plant_rate, (years + 1, reps))\nhr = plot(\n    mean(plant_rate, dims = 2),\n    ribbon = std(plant_rate, dims = 2),\n    label = \"Plant Rate\",\n    linewidth = 2,\n    color = palette(:default)[3],\n)\nnut = reshape(data.nutrients, (years + 1, reps))\nhn = plot(\n    mean(nut, dims = 2),\n    ribbon = std(nut, dims = 2),\n    label = \"Nutrients\",\n    linewidth = 2,\n)\nl = @layout [a; b c]\nplot(hl, hr, hn, layout = l, size = (1000, 700))","category":"page"},{"location":"#New-to-Julia","page":"Introduction","title":"New to Julia","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If you've never used Julia before there are a few things you will need to do to get LimnoSES running.","category":"page"},{"location":"#Install-Julia","page":"Introduction","title":"Install Julia","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"First, you'll need the Julia runtime. Install the version for your operating system from this link. You'll want the current stable release (v1.6.x at time of writing).","category":"page"},{"location":"#Adding-LimnoSES","page":"Introduction","title":"Adding LimnoSES","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Now you'll need to add the LimnoSES package to your system. Open the Julia REPL (short for Read-eval-print loop: it's the Julia command line). On linux and mac systems you can type julia at a prompt. For windows you can probably do the same or click an icon.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"It's nice to do this from a specific directory you want to work in, so if you're using a prompt: first make one, cd into it and then start julia. Starting from an icon, try cd(\"working/directory/path\"). You can use pwd() to make sure you're in the right place.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Now press ] to get into the REPL's package mode - you should see a (@v1.6) pkg> prompt. We're going to create a new project which is called whatever you named your folder. Say your folder was called shallow_lake, what we want to do at this prompt is type activate .. Now your prompt looks like: (shallow_lake) pkg>.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Since LimnoSES is in development, we add it like this:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"add https://github.com/Libbum/LimnoSES.jl","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In the near future it will be simpler, just add LimnoSES, but not right away.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Once the install is sorted, you can press backspace to get back to the green julia> prompt and type using LimnoSES. If all goes well you're ready!","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Now you can go through the Quickstart section.","category":"page"}]
}
